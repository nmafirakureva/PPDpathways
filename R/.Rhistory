names(D)[grepl("cost.", names(D))]
names(D)[grepl("ucost.", names(D))]
names(D)[grepl("^cost.", names(D))]
names(D)[grepl("^cost.", names(D))]
psa_data <- data.frame(
costs = rnorm(1000, mean = 5000, sd = 1000),  # Example costs
utility = rnorm(1000, mean = 0.8, sd = 0.1),  # Example utility values
probability = runif(1000, min = 0.6, max = 0.9),  # Example probabilities
ICER = rnorm(1000, mean = 20000, sd = 5000)  # Example outcome: ICER
)
View(psa_data)
# Step 2: Fit a Regression Model to Identify Influential Parameters
model <- lm(ICER ~ costs + utility + probability, data = psa_data)
# Display summary of the regression model
summary(model)
# Step 3: Calculate Partial Correlation Coefficients
partial_correlations <- function(model) {
# Extract model matrix and residuals
model_matrix <- model.matrix(model)
residuals <- resid(model)
# Calculate partial correlations for each parameter
partial_corrs <- sapply(2:ncol(model_matrix), function(i) {
cor(residuals, model_matrix[, i], use = "complete.obs")
})
return(partial_corrs)
}
# Calculate partial correlations for the model
partial_corrs <- partial_correlations(model)
print(partial_corrs)
# Step 4: One-Way Sensitivity Analysis
one_way_sensitivity <- function(data, param, outcome, range) {
sensitivity_results <- data.frame()
for (val in range) {
data[[param]] <- val  # Set parameter to a specific value
new_outcome <- predict(model, newdata = data)
sensitivity_results <- rbind(sensitivity_results, data.frame(param_value = val, outcome = mean(new_outcome)))
}
return(sensitivity_results)
}
# Example of one-way sensitivity analysis for "costs"
cost_range <- seq(4000, 6000, by = 100)
sensitivity_results <- one_way_sensitivity(psa_data, "costs", "ICER", cost_range)
# Plot the results of one-way sensitivity analysis
ggplot(sensitivity_results, aes(x = param_value, y = outcome)) +
geom_line() +
labs(title = "One-Way Sensitivity Analysis: Costs vs ICER", x = "Costs", y = "ICER")
# Step 5: Create a Tornado Plot
# Calculate outcome changes for each parameter
tornado_data <- psa_data %>%
summarise(across(c(costs, utility, probability), list(
low = ~ quantile(., 0.05),
high = ~ quantile(., 0.95)
))) %>%
pivot_longer(cols = everything(), names_to = c("parameter", ".value"), names_sep = "_")
# Compute ICER for each scenario
tornado_data <- tornado_data %>%
mutate(
ICER_low = predict(model, newdata = tibble(costs = costs_low, utility = utility_low, probability = probability_low)),
ICER_high = predict(model, newdata = tibble(costs = costs_high, utility = utility_high, probability = probability_high)),
diff = abs(ICER_high - ICER_low)
) %>%
arrange(desc(diff))
# Plot tornado plot
ggplot(tornado_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_errorbar(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
# Predict ICER for each low and high scenario
tornado_data <- tornado_data %>%
mutate(
ICER_low_costs = mean(predict(model, newdata = low_scenario %>% mutate(costs = costs_low))),
ICER_high_costs = mean(predict(model, newdata = high_scenario %>% mutate(costs = costs_high))),
ICER_low_utility = mean(predict(model, newdata = low_scenario %>% mutate(utility = utility_low))),
ICER_high_utility = mean(predict(model, newdata = high_scenario %>% mutate(utility = utility_high))),
ICER_low_probability = mean(predict(model, newdata = low_scenario %>% mutate(probability = probability_low))),
ICER_high_probability = mean(predict(model, newdata = high_scenario %>% mutate(probability = probability_high))
))
# Predict ICER for each low and high scenario
tornado_data <- tornado_data %>%
mutate(
ICER_low_costs = mean(predict(model, newdata = low_scenario %>% mutate(costs = costs_low))),
ICER_high_costs = mean(predict(model, newdata = high_scenario %>% mutate(costs = costs_high))),
ICER_low_utility = mean(predict(model, newdata = low_scenario %>% mutate(utility = utility_low))),
ICER_high_utility = mean(predict(model, newdata = high_scenario %>% mutate(utility = utility_high))),
ICER_low_probability = mean(predict(model, newdata = low_scenario %>% mutate(probability = probability_low))),
ICER_high_probability = mean(predict(model, newdata = high_scenario %>% mutate(probability = probability_high))
))
# Step 2: Fit a Regression Model to Identify Influential Parameters
model <- lm(ICER ~ costs + utility + probability, data = psa_data)
# Display summary of the regression model
summary(model)
# Step 3: Calculate Partial Correlation Coefficients
partial_correlations <- function(model) {
# Extract model matrix and residuals
model_matrix <- model.matrix(model)
residuals <- resid(model)
# Calculate partial correlations for each parameter
partial_corrs <- sapply(2:ncol(model_matrix), function(i) {
cor(residuals, model_matrix[, i], use = "complete.obs")
})
return(partial_corrs)
}
# Calculate partial correlations for the model
partial_corrs <- partial_correlations(model)
print(partial_corrs)
# Step 4: One-Way Sensitivity Analysis
one_way_sensitivity <- function(data, param, outcome, range) {
sensitivity_results <- data.frame()
for (val in range) {
data[[param]] <- val  # Set parameter to a specific value
new_outcome <- predict(model, newdata = data)
sensitivity_results <- rbind(sensitivity_results, data.frame(param_value = val, outcome = mean(new_outcome)))
}
return(sensitivity_results)
}
# Example of one-way sensitivity analysis for "costs"
cost_range <- seq(4000, 6000, by = 100)
sensitivity_results <- one_way_sensitivity(psa_data, "costs", "ICER", cost_range)
# Plot the results of one-way sensitivity analysis
ggplot(sensitivity_results, aes(x = param_value, y = outcome)) +
geom_line() +
labs(title = "One-Way Sensitivity Analysis: Costs vs ICER", x = "Costs", y = "ICER")
# Step 5: Create a Tornado Plot
# Calculate outcome changes for each parameter
# Tornado plot preparation
# Calculate the lower and upper bounds for each parameter
# Tornado plot preparation
# Calculate the lower and upper bounds for each parameter
tornado_data <- psa_data %>%
summarise(
costs_low = quantile(costs, 0.05),
costs_high = quantile(costs, 0.95),
utility_low = quantile(utility, 0.05),
utility_high = quantile(utility, 0.95),
probability_low = quantile(probability, 0.05),
probability_high = quantile(probability, 0.95)
)
# Create a new data frame for each scenario to compute ICER
low_scenario <- psa_data %>%
mutate(costs = tornado_data$costs_low,
utility = tornado_data$utility_low,
probability = tornado_data$probability_low)
high_scenario <- psa_data %>%
mutate(costs = tornado_data$costs_high,
utility = tornado_data$utility_high,
probability = tornado_data$probability_high)
# Predict ICER for each low and high scenario
tornado_data <- tornado_data %>%
mutate(
ICER_low_costs = mean(predict(model, newdata = low_scenario %>% mutate(costs = costs_low))),
ICER_high_costs = mean(predict(model, newdata = high_scenario %>% mutate(costs = costs_high))),
ICER_low_utility = mean(predict(model, newdata = low_scenario %>% mutate(utility = utility_low))),
ICER_high_utility = mean(predict(model, newdata = high_scenario %>% mutate(utility = utility_high))),
ICER_low_probability = mean(predict(model, newdata = low_scenario %>% mutate(probability = probability_low))),
ICER_high_probability = mean(predict(model, newdata = high_scenario %>% mutate(probability = probability_high))
))
# Compute the differences to identify the impact
tornado_plot_data <- tibble(
parameter = c("costs", "utility", "probability"),
ICER_low = c(tornado_data$ICER_low_costs, tornado_data$ICER_low_utility, tornado_data$ICER_low_probability),
ICER_high = c(tornado_data$ICER_high_costs, tornado_data$ICER_high_utility, tornado_data$ICER_high_probability),
diff = abs(ICER_high - ICER_low)
) %>%
arrange(desc(diff))
# Create tornado plot
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_errorbar(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
# Create tornado plot
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_col(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
# Create tornado plot
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_bar(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
psa_data
# Calculate lower and upper bounds for each parameter
tornado_data <- psa_data %>%
summarise(
costs_low = quantile(costs, 0.05),
costs_high = quantile(costs, 0.95),
utility_low = quantile(utility, 0.05),
utility_high = quantile(utility, 0.95),
probability_low = quantile(probability, 0.05),
probability_high = quantile(probability, 0.95)
)
# Create low and high scenarios for each parameter
low_scenario <- psa_data %>%
mutate(
costs = tornado_data$costs_low,
utility = tornado_data$utility_low,
probability = tornado_data$probability_low
)
high_scenario <- psa_data %>%
mutate(
costs = tornado_data$costs_high,
utility = tornado_data$utility_high,
probability = tornado_data$probability_high
)
# Predict ICER for each parameter's low and high values
tornado_data <- tornado_data %>%
mutate(
ICER_low_costs = mean(predict(model, newdata = low_scenario %>% mutate(costs = costs_low))),
ICER_high_costs = mean(predict(model, newdata = high_scenario %>% mutate(costs = costs_high))),
ICER_low_utility = mean(predict(model, newdata = low_scenario %>% mutate(utility = utility_low))),
ICER_high_utility = mean(predict(model, newdata = high_scenario %>% mutate(utility = utility_high))),
ICER_low_probability = mean(predict(model, newdata = low_scenario %>% mutate(probability = probability_low))),
ICER_high_probability = mean(predict(model, newdata = high_scenario %>% mutate(probability = probability_high)))
)
# Calculate differences for plotting
tornado_plot_data <- tibble(
parameter = c("costs", "utility", "probability"),
ICER_low = c(tornado_data$ICER_low_costs, tornado_data$ICER_low_utility, tornado_data$ICER_low_probability),
ICER_high = c(tornado_data$ICER_high_costs, tornado_data$ICER_high_utility, tornado_data$ICER_high_probability),
diff = abs(ICER_high - ICER_low)
) %>%
arrange(desc(diff))
# Generate the tornado plot with correct scale
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_errorbar(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
# Generate the tornado plot with correct scale
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_bar(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
# Load necessary libraries
library(dplyr)       # Data manipulation
library(ggplot2)     # Visualization
library(tidyr)       # Data transformation
# Step 1: Prepare the PSA Dataset
set.seed(123)
psa_data <- data.frame(
costs = rnorm(1000, mean = 5000, sd = 1000),  # Example costs
utility = rnorm(1000, mean = 0.8, sd = 0.1),  # Example utility values
probability = runif(1000, min = 0.6, max = 0.9),  # Example probabilities
ICER = rnorm(1000, mean = 20000, sd = 5000)  # Example outcome: ICER
)
# Step 2: Fit a Regression Model to Identify Influential Parameters
model <- lm(ICER ~ costs + utility + probability, data = psa_data)
# Display summary of the regression model
summary(model)
# Step 3: Calculate Partial Correlation Coefficients
partial_correlations <- function(model) {
# Extract model matrix and residuals
model_matrix <- model.matrix(model)
residuals <- resid(model)
# Calculate partial correlations for each parameter
partial_corrs <- sapply(2:ncol(model_matrix), function(i) {
cor(residuals, model_matrix[, i], use = "complete.obs")
})
return(partial_corrs)
}
# Calculate partial correlations for the model
partial_corrs <- partial_correlations(model)
print(partial_corrs)
# Step 4: One-Way Sensitivity Analysis
one_way_sensitivity <- function(data, param, outcome, range) {
sensitivity_results <- data.frame()
for (val in range) {
data[[param]] <- val  # Set parameter to a specific value
new_outcome <- predict(model, newdata = data)
sensitivity_results <- rbind(sensitivity_results, data.frame(param_value = val, outcome = mean(new_outcome)))
}
return(sensitivity_results)
}
# Example of one-way sensitivity analysis for "costs"
cost_range <- seq(4000, 6000, by = 100)
sensitivity_results <- one_way_sensitivity(psa_data, "costs", "ICER", cost_range)
# Plot the results of one-way sensitivity analysis
ggplot(sensitivity_results, aes(x = param_value, y = outcome)) +
geom_line() +
labs(title = "One-Way Sensitivity Analysis: Costs vs ICER", x = "Costs", y = "ICER")
# Step 5: Create a Tornado Plot
# Calculate outcome changes for each parameter
# Tornado plot preparation
# Calculate the lower and upper bounds for each parameter
# Tornado plot preparation
# Calculate the lower and upper bounds for each parameter
# Calculate lower and upper bounds for each parameter
tornado_data <- psa_data %>%
summarise(
costs_low = quantile(costs, 0.05),
costs_high = quantile(costs, 0.95),
utility_low = quantile(utility, 0.05),
utility_high = quantile(utility, 0.95),
probability_low = quantile(probability, 0.05),
probability_high = quantile(probability, 0.95)
)
# Create low and high scenarios for each parameter
low_scenario <- psa_data %>%
mutate(
costs = tornado_data$costs_low,
utility = tornado_data$utility_low,
probability = tornado_data$probability_low
)
high_scenario <- psa_data %>%
mutate(
costs = tornado_data$costs_high,
utility = tornado_data$utility_high,
probability = tornado_data$probability_high
)
# Predict ICER for each parameter's low and high values
tornado_data <- tornado_data %>%
mutate(
ICER_low_costs = mean(predict(model, newdata = low_scenario %>% mutate(costs = costs_low))),
ICER_high_costs = mean(predict(model, newdata = high_scenario %>% mutate(costs = costs_high))),
ICER_low_utility = mean(predict(model, newdata = low_scenario %>% mutate(utility = utility_low))),
ICER_high_utility = mean(predict(model, newdata = high_scenario %>% mutate(utility = utility_high))),
ICER_low_probability = mean(predict(model, newdata = low_scenario %>% mutate(probability = probability_low))),
ICER_high_probability = mean(predict(model, newdata = high_scenario %>% mutate(probability = probability_high)))
)
# Calculate differences for plotting
tornado_plot_data <- tibble(
parameter = c("costs", "utility", "probability"),
ICER_low = c(tornado_data$ICER_low_costs, tornado_data$ICER_low_utility, tornado_data$ICER_low_probability),
ICER_high = c(tornado_data$ICER_high_costs, tornado_data$ICER_high_utility, tornado_data$ICER_high_probability),
diff = abs(ICER_high - ICER_low)
) %>%
arrange(desc(diff))
# Generate the tornado plot with correct scale
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_errorbar(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
# Generate the tornado plot with correct scale
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_bar(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_bar(width = 0.2)
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_errorbar(width = 0.2)
# Generate the tornado plot with correct scale
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), ymin = ICER_low, ymax = ICER_high)) +
geom_errorbar(width = 0.2) +
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER")
# Ensure your data has a 'diff' column representing the difference between ICER_high and ICER_low
tornado_plot_data <- tornado_plot_data %>%
mutate(diff = ICER_high - ICER_low)  # Calculate the difference between high and low ICER
# Generate the tornado plot using bars
ggplot(tornado_plot_data, aes(x = reorder(parameter, diff), y = diff, fill = parameter)) +
geom_col(width = 0.6) +  # Use geom_col for bar plot, and adjust width as needed
coord_flip() +
labs(title = "Tornado Plot", x = "Parameter", y = "ICER Difference") +
theme_minimal() +  # Optional: Apply a minimal theme for a cleaner look
theme(legend.position = "none")  # Remove legend if you don't need it
tornado_plot_data
library(tornado)
library(modelr)
cost_inputs<- c("ucost.att.dots","ucost.chest.xray","ucost.contact.tracing","ucost.dsatt.drugs","ucost.dstb.ipd",
"ucost.dstb.opd.visit","ucost.igra.test","ucost.ltbi.drugs","ucost.mdratt.drugs","ucost.mdrtb.ipd.smear.positive",
"ucost.mdrtb.opd.visit","ucost.nhs.tb.service","ucost.overheads","ucost.prison.bedwatch","ucost.prison.cell.isolation",
"ucost.prison.escort","ucost.prison.gp.assess","ucost.tb.investigations","ucost.tb.sympt.screen","ucost.dots",
"ucost.tpt.opd.visit","ucost.mdrtb.opd.visits","ucost.dstb.opd.visits")
cost_outputs<- c("cost.prison.gp.assessessment","cost.contact.management","cost.tb.evaluation","cost.attending.nhs.tb.service","cost.att.initiation",
"cost.tpt.initiation","cost.prison.isolation","cost.chest.xray","cost.inpatient","cost.att.complete","cost.att.incomplete",
"cost.tpt.complete","cost.tpt.incomplete","cost.tb.sympt.screen","cost.igra.test","cost.soc","cost.ppd.soc","cost.nhs.soc",
"cost.int","cost.ppd.int","cost.nhs.int")
## create restricted PSA
psaout <- D |>
select(isoz, id,tb, all_of(cost_inputs), all_of(cost_outputs)) |>
rename(iso3 = isoz)
names(psaout)
prob_inputs <- names(D)[grepl("prop.", names(D))]
prob_inputs
vrz.soc <- showAllParmz(SOC)
vrz.int <- showAllParmz(INT)
vrz <- c(vrz.soc,
vrz.int)
vrz <- unique(vrz) #NOTE
# drop all soc parameters
vrz <- vrz[!grepl("soc.", vrz)]
#
# drop all parameter ending withtb.dx. They should be covered by sensitivity
vrz <- vrz[!grepl("tb.dx$", vrz)]
#
# get parameters scaled down under SOC
soc <- c('soc.prop.tb.sympt.screen', 'soc.prop.prev.xray', 'soc.prop.xray', 'soc.prop.igra.tested', 'sens.xpert', 'spec.xpert')
vrz <- c(vrz, soc)
## create restricted PSA
psaout <- D |>
select(isoz, id,tb, soc_att_check, soc_att_cost, soc_tpt_check,soc_tpt_cost, soc_notx_check,
soc_notx_cost,int_att_check,int_att_cost,int_tpt_check,int_tpt_cost,int_notx_check,int_notx_cost, all_of(vrz)) |>
rename(iso3 = isoz)
int_vrz <- vrz[grepl("int", vrz)]
int <- c('int.prop.tb.sympt.screen', 'int.prop.prev.xray', 'int.prop.xray', 'int.prop.igra.tested')
int_vrz <- int_vrz[!int_vrz %in% int]
int_vrz_new <-gsub("int.", "", int_vrz)
psaout <- psaout %>%
rename_with(
~ int_vrz_new[match(., int_vrz)],
.cols = int_vrz,
names_repair = "minimal"
)
names(psaout)
psaout <- psaout |>
mutate(
soc_att_cost=soc_att_cost/soc_att_check,
soc_tpt_cost=soc_tpt_cost/soc_tpt_check,
soc_notx_cost=soc_notx_cost/soc_notx_check,
int_att_cost=int_att_cost/int_att_check,
int_tpt_cost=int_tpt_cost/int_tpt_check,
int_notx_cost=int_notx_cost/int_notx_check
)
# set inf to 0
psaout <- psaout %>%
mutate(across(where(is.numeric), ~ ifelse(is.infinite(.), 0, .)))
psa_dat <- psaout
# extract outcomes and explanatory variables
(outcome_vars <- names(psaout)[grepl('_att_|_tpt_|_notx_', names(psaout))])  # Find columns with 'cost' in the name'
# drop <- names(psaout)[grepl('^D|cost', names(psaout))]
explanatory_vars <- names(psa_dat)[sapply(psa_dat, is.numeric)]  # Select only numeric columns
explanatory_vars <- setdiff(explanatory_vars, outcome_vars)  # Exclude outcome variables
explanatory_vars <- explanatory_vars[!explanatory_vars %in% c('id','iso3', 'tb')]
explanatory_vars
(outcome_vars <- names(psaout)[grepl('_cost', names(psaout))])  # Find columns with 'cost' in the name'
explanatory_vars
outcome_vars
# keep only the variables that have variance
paramvar <- psaout |> select(all_of(explanatory_vars)) %>% summarise_all(function(x) var(x)) # Calculate variance for each variable
explanatory_vars <- names(paramvar)[which(paramvar!=0)]
# Define the explanatory variables
explanatory_vars <- c("cost.tb.sympt.screen",
"cost.nhs.tb.service", "cost.prison.escort", "cost.dstb.opd.visit",
"cost.mdrtb.opd.visits", "cost.dsatt.drugs", "cost.mdratt.drugs",
"cost.dots", "cost.inpatient",
"cost.prison.gp.assess", "cost.chest.xray", "cost.tb.investigations",
"cost.contact.tracing", "cost.ltbi.drugs", "cost.tpt.opd.visit",
"attend.nhs.referral", "prop.starting.att",
# "prop.prev.tb.dx.started.att", "prop.prev.tb.dx.still.on.att",
"prop.completing.tpt",
"prop.starting.tpt",
"prop.staying.o3.months", "prop.staying.u3.months.uk",
"int.prop.xray", "prop.igra.test.positive", "int.prop.igra.tested",
"prop.tb.suspicion", "prop.gp.assessment",
"prop.no.prev.tb.dx.symp", "int.prop.tb.sympt.screen",
"soc.prop.tb.sympt.screen", "soc.prop.xray", "soc.prop.igra.tested",
"sens.xpert","spec.xpert")
psa_dat <- psa_dat |>
rename(prop.tb.suspicion = prop.no.prev.tb.dx.symp.tb.suspicion,
prop.gp.assessment = prop.no.prev.tb.dx.symp.gp.assess,
prop.starting.tpt = prop.staying.o3.months.tpt,
prop.completing.tpt = prop.staying.o3.months.complete.tpt)
by_country <- psa_dat %>%
group_by(tb) %>%
nest()
# Sample data structure for tornado plot
tornado_plot_data <- data.frame(
parameter = c("Param1", "Param2", "Param3"),
ICER_low = c(5000, 7000, 9000),
ICER_high = c(8000, 10000, 11000),
QALY_low = c(1.2, 1.5, 1.3),
QALY_high = c(1.6, 2.0, 1.8),
Costs_low = c(20000, 25000, 30000),
Costs_high = c(25000, 30000, 35000)
)
tornado_plot_data
# Reshape the data to a long format for multiple outcomes
tornado_long_data <- tornado_plot_data %>%
pivot_longer(cols = starts_with("ICER") | starts_with("QALY") | starts_with("Costs"),
names_to = c("Outcome", "Type"),
names_sep = "_",
values_to = "Value") %>%
pivot_wider(names_from = Type, values_from = Value) %>%
mutate(diff = High - Low)
# Sample data structure for tornado plot
tornado_plot_data <- data.frame(
parameter = c("Param1", "Param2", "Param3"),
ICER_low = c(5000, 7000, 9000),
ICER_high = c(8000, 10000, 11000),
QALY_low = c(1.2, 1.5, 1.3),
QALY_high = c(1.6, 2.0, 1.8),
Costs_low = c(20000, 25000, 30000),
Costs_high = c(25000, 30000, 35000)
)
# Reshape the data to a long format for multiple outcomes
tornado_long_data <- tornado_plot_data %>%
pivot_longer(cols = starts_with("ICER") | starts_with("QALY") | starts_with("Costs"),
names_to = c("Outcome", "Type"),
names_sep = "_",
values_to = "Value") %>%
pivot_wider(names_from = Type, values_from = Value) %>%
mutate(diff = High - Low)
tornado_plot_data %>%
pivot_longer(cols = starts_with("ICER") | starts_with("QALY") | starts_with("Costs"),
names_to = c("Outcome", "Type"),
names_sep = "_",
values_to = "Value") %>%
pivot_wider(names_from = Type, values_from = Value)
# Reshape the data to a long format for multiple outcomes
tornado_long_data <- tornado_plot_data %>%
pivot_longer(cols = starts_with("ICER") | starts_with("QALY") | starts_with("Costs"),
names_to = c("Outcome", "Type"),
names_sep = "_",
values_to = "Value") %>%
pivot_wider(names_from = Type, values_from = Value) %>%
mutate(diff = high - low)
# Generate tornado plot for multiple outcomes
ggplot(tornado_long_data, aes(x = reorder(parameter, diff), y = diff, fill = Outcome)) +
geom_col(width = 0.6, position = position_dodge(width = 0.8)) +  # Grouped bars for each outcome
coord_flip() +
labs(title = "Tornado Plot for Multiple Outcomes", x = "Parameter", y = "Difference in Outcome") +
theme_minimal() +
theme(legend.position = "right")  # Adjust legend position
